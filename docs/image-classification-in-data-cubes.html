<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Image Classification in Data Cubes | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes</title>
<meta name="author" content="Gilberto Camara">
<meta name="author" content="Rolf Simoes">
<meta name="author" content="Felipe Souza">
<meta name="author" content="Charlotte Pelletier">
<meta name="author" content="Alber Sanchez">
<meta name="author" content="Pedro Ribeiro Andrade">
<meta name="author" content="Karine Ferreira">
<meta name="author" content="Gilberto Queiroz">
<meta name="description" content="In this chapter, we discuss how to classify data cubes by providing a step-by-step example. Our study area is the state of Rondonia, Brazil, that underwent substantial deforestation in the last...">
<meta name="generator" content="bookdown 0.32 with bs4_book()">
<meta property="og:title" content="Image Classification in Data Cubes | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta property="og:type" content="book">
<meta property="og:image" content="/images/cover_sits_book.png">
<meta property="og:description" content="In this chapter, we discuss how to classify data cubes by providing a step-by-step example. Our study area is the state of Rondonia, Brazil, that underwent substantial deforestation in the last...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Image Classification in Data Cubes | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta name="twitter:description" content="In this chapter, we discuss how to classify data cubes by providing a step-by-step example. Our study area is the state of Rondonia, Brazil, that underwent substantial deforestation in the last...">
<meta name="twitter:image" content="/images/cover_sits_book.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/IBM_Plex_Serif-0.4.4/font.css" rel="stylesheet">
<link href="libs/IBM_Plex_Mono-0.4.4/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.4.2/transition.js"></script><script src="libs/bs3compat-0.4.2/tabs.js"></script><script src="libs/bs3compat-0.4.2/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title=""><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="setup.html">Setup</a></li>
<li><a class="" href="acknowledgements.html">Acknowledgements</a></li>
<li><a class="" href="introduction-to-sits.html">Introduction to SITS</a></li>
<li><a class="" href="earth-observation-data-cubes.html">Earth observation data cubes</a></li>
<li><a class="" href="operations-on-data-cubes.html">Operations on Data Cubes</a></li>
<li><a class="" href="working-with-time-series.html">Working with time series</a></li>
<li><a class="" href="improving-the-quality-of-training-samples.html">Improving the Quality of Training Samples</a></li>
<li><a class="" href="machine-learning-for-data-cubes.html">Machine Learning for Data Cubes</a></li>
<li><a class="active" href="image-classification-in-data-cubes.html">Image Classification in Data Cubes</a></li>
<li><a class="" href="validation-and-accuracy-measurements.html">Validation and accuracy measurements</a></li>
<li><a class="" href="uncertainty-and-active-learning.html">Uncertainty and active learning</a></li>
<li><a class="" href="design-and-extensibility-considerations.html">Design and extensibility considerations</a></li>
<li><a class="" href="technical-annex.html">Technical Annex</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="image-classification-in-data-cubes" class="section level1 unnumbered">
<h1>Image Classification in Data Cubes<a class="anchor" aria-label="anchor" href="#image-classification-in-data-cubes"><i class="fas fa-link"></i></a>
</h1>
<p><a href="https://www.kaggle.com/esensing/raster-classification-in-sits" target="_blank"><img src="https://kaggle.com/static/images/open-in-kaggle.svg"></a></p>
<p>In this chapter, we discuss how to classify data cubes by providing a step-by-step example. Our study area is the state of Rondonia, Brazil, that underwent substantial deforestation in the last decades. According to surveys done by Brazil’s National Institute for Space Research (INPE) using satellite images, from 1988 to 2021 more than 6.46 million hectares of natural tropical forest been cut for selected a study area located in the Bahia state. The objective of the case study is to detect deforested areas.</p>
<div id="training-the-classification-model" class="section level2 unnumbered">
<h2>Training the classification model<a class="anchor" aria-label="anchor" href="#training-the-classification-model"><i class="fas fa-link"></i></a>
</h2>
<p>The case study uses the training data set <code>samples_prodes_4bands</code>, available in package <code>sitsdata</code>. This data set consists of 480 samples collected from Sentinel-2 images covering the state of Rondonia. The samples are intended to detect deforestation events, and include four classes: “Forest”, “Burned_Area”, “Cleared_Area”, and “Highly_Degraded”. The time series cover a set of 29 dates with a period of 16 days, ranging from “2020-06-04” to “2021-08-26”. The data has 12 attributes, including original bands (“B02”, “B03”, “B04”, “B05”, “B08”, “B8A”, “B11”, and “B12”) and indices (“NDVI”, “EVI” and “NBR”).</p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/e-sensing/sitsdata/">sitsdata</a></span><span class="op">)</span></span>
<span><span class="co"># obtain the samples</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"samples_prodes_4classes"</span><span class="op">)</span></span>
<span><span class="co"># show the contents of the samples</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_labels_summary.html">sits_labels_summary</a></span><span class="op">(</span><span class="va">samples_prodes_4classes</span><span class="op">)</span></span></code></pre></div>
<pre class="sourceCode"><code>#&gt; # A tibble: 4 × 3
#&gt;   label           count  prop
#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Burned_Area        96 0.244
#&gt; 2 Cleared_Area      115 0.293
#&gt; 3 Forest            107 0.272
#&gt; 4 Highly_Degraded    75 0.191</code></pre>
</div>
<div id="building-a-data-cube" class="section level2 unnumbered">
<h2>Building a data cube<a class="anchor" aria-label="anchor" href="#building-a-data-cube"><i class="fas fa-link"></i></a>
</h2>
<p>We now build a data cube from the Sentinel-2 images available in the package <code>sitsdata</code>. These images were downloaded from the <code>SENTINEL-2-L2A</code> collection in Microsoft Planetary Computer (<code>MPC</code>). We have chosen bands “BO2”, “B8A” and “B11” images in a small area of 1000 x 1000 pixels the state of Rondonia to serve as examples. As explained in the “Earth observation data cubes” chapter, we need to inform <code>sits</code> how to parse these file names to obtain tile, date and band information. Image files are named according to the convention “cube_tile_band_date” (e.g., <code>cube_20LKP_BO2_2020_06_04.tif</code>).</p>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># files are available in a local directory</span></span>
<span><span class="va">data_dir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata/Rondonia-20LKP/"</span>, package <span class="op">=</span> <span class="st">"sitsdata"</span><span class="op">)</span></span>
<span><span class="co"># read data cube</span></span>
<span><span class="va">ro_cube_20LKP</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_cube.html">sits_cube</a></span><span class="op">(</span></span>
<span>  source <span class="op">=</span> <span class="st">"MPC"</span>,</span>
<span>  collection <span class="op">=</span> <span class="st">"SENTINEL-2-L2A"</span>,</span>
<span>  data_dir <span class="op">=</span> <span class="va">data_dir</span>,</span>
<span>  parse_info <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"X1"</span>, <span class="st">"tile"</span>, <span class="st">"band"</span>, <span class="st">"date"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># plot the cube</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">ro_cube_20LKP</span>, dates <span class="op">=</span> <span class="st">"2021-07-25"</span>, red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-110"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-110-1.png" alt="Color composite image of the cube for date 2021-07-25" width="90%"><p class="caption">
Figure 59: Color composite image of the cube for date 2021-07-25
</p>
</div>
</div>
<div id="training-a-deep-learning-model" class="section level2 unnumbered">
<h2>Training a deep learning model<a class="anchor" aria-label="anchor" href="#training-a-deep-learning-model"><i class="fas fa-link"></i></a>
</h2>
<p>The next step is to train a LighTAE model, using the <code>adamw</code> optimizer and a learning rate of 0.001. Since the images only have bands <code>BO2</code>, <code>B8A</code> and <code>B11</code>, we select these bands from the training data.</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># use only the bands available in the cube</span></span>
<span><span class="va">samples_3bands</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_select.html">sits_select</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="va">samples_prodes_4classes</span>,</span>
<span>  bands <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_bands.html">sits_bands</a></span><span class="op">(</span><span class="va">ro_cube_20LKP</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># train model using LightTAE algorithm</span></span>
<span><span class="va">ltae_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_train.html">sits_train</a></span><span class="op">(</span></span>
<span>  samples <span class="op">=</span> <span class="va">samples_3bands</span>,</span>
<span>  ml_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_lighttae.html">sits_lighttae</a></span><span class="op">(</span></span>
<span>    opt_hparams <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>lr <span class="op">=</span> <span class="fl">0.001</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># plot the evolution of the model</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">ltae_model</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-111"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-111-1.png" alt="Training evolution of LightTAE model." width="80%"><p class="caption">
Figure 60: Training evolution of LightTAE model.
</p>
</div>
</div>
<div id="classification-using-parallel-processing" class="section level2 unnumbered">
<h2>Classification using parallel processing<a class="anchor" aria-label="anchor" href="#classification-using-parallel-processing"><i class="fas fa-link"></i></a>
</h2>
<p>To classify both data cubes and sets of time series, use the function <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code>, which uses parallel processing for speed up performance, as described in the end of this Chapter. Its most relevant parameters are: (a) <code>data</code>, either a data cube or a set of time series; (b) <code>ml_model</code>, a trained model using one of the machine learning methods provided; (c) <code>multicores</code>, number of CPU cores that will be used for processing; (d) <code>memsize</code>, memory available for classification; (e) <code>output_dir</code>, directory where results will be stored; (f) <code>version</code>, for version control. If users want to follow the processing steps, they should turn on the parameters <code>verbose</code> to print information and <code>progress</code> to get a progress bar. The result of the classification is a data cube with a set of probability layers, one for each output class. Each probability layer contains the model’s assessment of how likely is each pixel to belong to the related class. The probability cube can be visualized with <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>.</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># classify data cube</span></span>
<span><span class="va">ro_cube_20LKP_probs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="va">ro_cube_20LKP</span>,</span>
<span>  ml_model <span class="op">=</span> <span class="va">ltae_model</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"ltae"</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">ro_cube_20LKP_probs</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-112"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-112-1.png" alt="Probability maps produced by LightTAE model." width="80%"><p class="caption">
Figure 61: Probability maps produced by LightTAE model.
</p>
</div>
<p>The probability cube is a useful tool for data analysis. It is used for post-processing smoothing, as described in this Chapter, but also in uncertainty estimates and active learning, as described in the “Uncertainty and Active Learning” Chapter.</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># generate thematic map</span></span>
<span><span class="va">defor_map</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">ro_cube_20LKP_probs</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"no_smooth"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">defor_map</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-113"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-113-1.png" alt="Final classification map." width="100%"><p class="caption">
Figure 62: Final classification map.
</p>
</div>
<p>The resulting labelled map shows a number of likely misclassified pixels which are shown as small patches surrounded by a different class. These outliers are a side-effect of pixel-based time series classification. Images contain many mixed pixels irrespective of the resolution, and there is a considerable degree of data variability in each class. These effects lead to outliers whose chance of misclassification is significant. To improve this result, <code>sits</code> includes post-processing smoothing methods that use spatial context of the probability cubes.</p>
</div>
<div id="post-classification-smoothing" class="section level2 unnumbered">
<h2>Post-classification smoothing<a class="anchor" aria-label="anchor" href="#post-classification-smoothing"><i class="fas fa-link"></i></a>
</h2>
<p>Smoothing methods are an important complement to machine learning algorithms for image classification. Since these methods are mostly pixel-based, it is useful to complement them with post-processing smoothing to include spatial information in the result. For each pixel, machine learning and other statistical algorithms provide the probabilities of that pixel belonging to each of the classes. As a first step in obtaining a result, each pixel is assigned to the class whose probability is higher. After this step, smoothing methods use class probabilities to detect and correct outliers or misclassified pixels.</p>
<p>Image classification post-processing has been defined as “a refinement of the labelling in a classified image in order to enhance its classification accuracy” <span class="citation"><a href="references.html#ref-Huang2014" role="doc-biblioref">[79]</a></span>. In remote sensing image analysis, these procedures are used to combine pixel-based classification methods with a spatial post-processing method to remove outliers and misclassified pixels. For pixel-based classifiers, post-processing methods enable the inclusion of spatial information in the final results.</p>
<p>Post-processing is a desirable step in any classification process. To offset these problems, most post-processing methods use the “smoothness assumption” <span class="citation"><a href="references.html#ref-Schindler2012" role="doc-biblioref">[80]</a></span>: nearby pixels tend to have the same label. To put this assumption in practice, smoothing methods use the neighborhood information to remove outliers and enhance consistency in the resulting product. The spatial smoothing methods are available in <code>sits</code> are bayesian smoothing and bilinear smoothing. These methods are called using the <code><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth()</a></code> function, as shown in the examples below.</p>
</div>
<div id="bayesian-smoothing" class="section level2 unnumbered">
<h2>Bayesian smoothing<a class="anchor" aria-label="anchor" href="#bayesian-smoothing"><i class="fas fa-link"></i></a>
</h2>
<p>The assumption of all spatial smoothing methods is the existence of a spatial autocorrelation effect between a pixel and its neighbors. Spatial autocorrelation describes the degree of similarity between pixels that are located close to each other. In land use classification, class probabilities of pixels in a neighborhood are mostly similar. Pixels with high probabilities of being labelled “Forest” should be surrounded by pixels with similar class probabilities. However, sometimes a pixel with high probability for a given class (e.g., “Crops”) has neighbors with which have low to moderate probabilities for this class. Bayesian smoothing uses the class probability to estimate if this is a classification error.</p>
<p>Bayesian inference can be thought of as way of coherently updating our uncertainty in the light of new evidence. It allows the inclusion of expert knowledge on the derivation of probabilities. Bayesian smoothing works by considering the combination of two elements: (a) our prior belief on class probabilities; (b) the estimated probabilities for a given pixel. To estimate prior distribution to the class probabilities for each pixel, we use the values for its neighbors. The assumption is that, at local level, class probabilities should be similar and provide the baseline for comparison with the pixel values produced by the classifier. Based on these two elements, Bayesian smoothing adjusts the probabilities for the pixel based on our prior beliefs.</p>
<p>The intuition for Bayesian smoothing is that homogeneous neighborhoods should have the same class. These situations occur when there is a high average probability for a single class, associated with a low variance. In this case, local effects dominate. Pixels which have been assigned to a different class are updated to the one that dominates the neighborhood. In these case, the prior probability is said to be informative. By contrast, in neighborhoods where the average probability for the most frequent class is not high and that have a high variance in its values, the pixel’s assigned class is likely not to be updated.</p>
<p>To run Bayesian smoothing, the parameter of <code><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth()</a></code> are: (a) <code>cube</code>, a probability cube produced by <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code>; (b) <code>type</code> should be <code>bayes</code> (the default); (c) <code>window_size</code>, the local window to compute the neighborhood probabilities; (d) <code>smoothness</code>, an estimate of the local variance (see Technical Annex for details); (e) <code>multicores</code>, number of CPU cores that will be used for processing; (f) <code>memsize</code>, memory available for classification; (g) <code>output_dir</code>, directory where results will be stored; (h) <code>version</code>, for version control. The resulting cube can be visualized with <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>. The bigger one sets the <code>window_size</code> and <code>smoothness</code> parameters, the stronger the adjustments will be. In what follows, we compare two situations of smoothing effects, by varying the <code>window_size</code> and <code>smoothness</code> parameters</p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># compute Bayesian smoothing</span></span>
<span><span class="va">cube_smooth_w9_s20</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">ro_cube_20LKP_probs</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"bayes"</span>,</span>
<span>  window_size <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  smoothness <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bayes_w9_s20"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">cube_smooth_w9_s20</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-114"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-114-1.png" alt="Probability maps after bayesian smoothing." width="90%"><p class="caption">
Figure 63: Probability maps after bayesian smoothing.
</p>
</div>
<p>Bayesian smoothing has removed some of local variability associated to misclassified pixels which are different from their neighbors. The impact of smoothing is best appreciated comparing the labelled map produced without smoothing to the one that follows the procedure, as shown below.</p>
<div class="sourceCode" id="cb113"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># generate thematic map</span></span>
<span><span class="va">defor_map_smooth_w9_20</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">cube_smooth_w9_s20</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bayes_w9_s20"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">defor_map_smooth_w9_20</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-115"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-115-1.png" alt="Final classification map after Bayesian smoothing with 5 x 5 window and smoothness = 30." width="90%"><p class="caption">
Figure 64: Final classification map after Bayesian smoothing with 5 x 5 window and smoothness = 30.
</p>
</div>
<p>To produce an even stronger smoothing effect, the example below uses bigger values for <code>window_size</code> and <code>smoothness</code>.</p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># compute Bayesian smoothing</span></span>
<span><span class="va">cube_smooth_w13_s80</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">ro_cube_20LKP_probs</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"bayes"</span>,</span>
<span>  window_size <span class="op">=</span> <span class="fl">13</span>,</span>
<span>  smoothness <span class="op">=</span> <span class="fl">80</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bayes_w13_s80"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">cube_smooth_w13_s80</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-116"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-116-1.png" alt="Probability maps after bayesian smoothing with 9 x 9 window smoothness = 80." width="90%"><p class="caption">
Figure 65: Probability maps after bayesian smoothing with 9 x 9 window smoothness = 80.
</p>
</div>
<p>Comparing the two maps, it is apparent that the smoothing procedure has reduced a lot of the noise in the original classification and produced a more homogeneous result. Although more pleasing to the eye, this map may not be be more accurate than the previous one, since much spatial details has been lost.</p>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># generate thematic map</span></span>
<span><span class="va">defor_map_smooth_w13_s80</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">cube_smooth_w13_s80</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bayes_w13_s80"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">defor_map_smooth_w13_s80</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-117"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-117-1.png" alt="Final classification map after Bayesian smoothing with 9 x 9 size." width="90%"><p class="caption">
Figure 66: Final classification map after Bayesian smoothing with 9 x 9 size.
</p>
</div>
</div>
<div id="bilateral-smoothing" class="section level2 unnumbered">
<h2>Bilateral smoothing<a class="anchor" aria-label="anchor" href="#bilateral-smoothing"><i class="fas fa-link"></i></a>
</h2>
<p>One of the problems with post-classification smoothing is that we would like to remove noisy pixels (e.g., a pixel with high probability of being labeled “Forest” in the midst of pixels likely to be labeled “Cerrado”), but would also like to preserve the edges between areas. Because of its design, bilateral filter has proven to be a useful method for post-classification processing since it preserves edges while removing noisy pixels <span class="citation"><a href="references.html#ref-Schindler2012" role="doc-biblioref">[80]</a></span>.</p>
<p>Bilateral smoothing combines proximity (combining pixels which are close) and similarity (comparing the values of the pixels) <span class="citation"><a href="references.html#ref-Tomasi1998" role="doc-biblioref">[81]</a></span>. If most of the pixels in a neighborhood have similar values, it is easy to identify outliers and noisy pixels. In contrast, there is a strong difference between the values of pixels in a neighborhood, it is possible that the pixel is located in a class boundary. The method takes a considers two factors: the distance between the pixel and its neighbors, and the difference in class probabilities between them. Each of the values contributes according to a Gaussian kernel. These factors are calculated independently. Big difference between class probability values reduce the influence of the neighbor in the smoothed pixel. Big distances between pixels also reduce the impact of neighbors.</p>
<p>To run bilateral smoothing, the parameter of <code><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth()</a></code> are: (a) <code>cube</code>, a probability cube produced by <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code>; (b) <code>type</code> should be <code>bilateral</code>; (c) <code>window_size</code>, the local window to compute the neighborhood probabilities; (d) <code>sigma</code>, an estimate of the variance of the Gaussian kernel based on distances (see Technical Annex for details); (e) <code>tau</code>, an estimate of the variance of the Gaussian kernel based on local probabilities; (f) <code>multicores</code>, number of CPU cores that will be used for processing; (g) <code>memsize</code>, memory available for classification; (h) <code>output_dir</code>, directory where results will be stored; (v) <code>version</code>, for version control. The resulting cube can be visualized with <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>.</p>
<p>The bigger one sets the <code>window_size</code>, the stronger the adjustments will be. The <code>sigma</code> parameter controls the effects of distance; larger values will reduce the influence of the neighbors. The <code>tau</code> parameter controls the influence of the class probabilities of the neighbors. Larger values of <code>sigma</code> will increase the influence of the neighbors. To achieve a satisfactory result, we need to balance the <code>sigma</code> and <code>tau</code>. As a general rule, the values of <code>tau</code> should range from 0.05 to 0.50, while the values of <code>sigma</code> should vary between 4 and 16<span class="citation"><a href="references.html#ref-Paris2007" role="doc-biblioref">[82]</a></span>. The default values adopted in <code>sits</code> are <code>tau = 0.1</code> and <code>sigma = 8</code>. As the best values of <code>sigma</code> and <code>tau</code> depend on the variance of the noisy pixels, users are encouraged to experiment and find parameter values that best fit their requirements.</p>
<p>The following example shows the behavior of the bilateral smoother and its impact on the classification map. The results show only a moderate reduction of classification noise.</p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># smooth the result with a bilateral filter</span></span>
<span><span class="va">cube_smooth_bil_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">ro_cube_20LKP_probs</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"bilateral"</span>,</span>
<span>  window_size <span class="op">=</span> <span class="fl">5</span>,</span>
<span>  sigma <span class="op">=</span> <span class="fl">8</span>,</span>
<span>  tau <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bil_w5_s8_t01"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># label the smoothed probability images</span></span>
<span><span class="va">map_bil_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">cube_smooth_bil_1</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bil_w5_s8_t01"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">map_bil_1</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-118"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-118-1.png" alt="Classified image with bilateral smoothing" width="90%"><p class="caption">
Figure 67: Classified image with bilateral smoothing
</p>
</div>
<p>For a stronger reduction in classification noise, we can increase the window size, while reducing the variance of the Gaussian kernels by decreasing <code>sigma</code> and <code>tau</code>.</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># smooth the result with a bilateral filter</span></span>
<span><span class="va">cube_smooth_bil_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">ro_cube_20LKP_probs</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"bilateral"</span>,</span>
<span>  window_size <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  sigma <span class="op">=</span> <span class="fl">16</span>,</span>
<span>  tau <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bil_w9_s16_t05"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># label the smoothed probability images</span></span>
<span><span class="va">map_bil_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">cube_smooth_bil_2</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  memsize <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  version <span class="op">=</span> <span class="st">"bil_w9_s16_t05"</span>,</span>
<span>  output_dir <span class="op">=</span> <span class="st">"./tempdir/chp8"</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">map_bil_2</span>, palette <span class="op">=</span> <span class="st">"YlGn"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-119"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-119-1.png" alt="Classified image with bilateral smoothing" width="90%"><p class="caption">
Figure 68: Classified image with bilateral smoothing
</p>
</div>
<p>Bayesian smoothing tends to produce more homogeneous labeled images than bilateral smoothing. However, some spatial details and some edges are better preserved by the bilateral method. Choosing between the methods depends on user needs and requirements. Since Bayesian smoothing is based on class probabilities and is simpler to parameterize than bilateral smoothing, we recommend the former rather than the latter. In any case, as stated by Schindler <span class="citation"><a href="references.html#ref-Schindler2012" role="doc-biblioref">[80]</a></span>, smoothing improves the quality of classified images and thus should be applied in most situations.</p>
<div id="how-parallel-processing-works" class="section level3 unnumbered">
<h3>How parallel processing works<a class="anchor" aria-label="anchor" href="#how-parallel-processing-works"><i class="fas fa-link"></i></a>
</h3>
<p>This section provides an overview of how the functions <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code>, <code><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth()</a></code> and <code><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification()</a></code> process images in parallel. To achieve efficiency, <code>sits</code> implements a fault tolerant multitasking procedure for big EO data classification. Users are not burdened with the need to learn how to do multiprocessing. Thus, their learning curve is shortened. Image classification in <code>sits</code> is done by a cluster of independent workers linked to a virtual machine. To avoid communication overhead, all large payloads are read and stored independently; direct interaction between the main process and the workers is kept at a minimum.</p>
<p>The classification procedure benefits from the fact that most images available in cloud collections are stored as COGs (cloud-optimized Geotiff). COGs are a regular GeoTIFF files organized in regular square blocks to improve visualization and access for large data sets. Thus, data requests can be optimized to access only portions of the images. All cloud services supported by <code>sits</code> use COG files. The classification algorithm in <code>sits</code> uses COGs to ensure optimal data access, reducing I/O demand as much as possible.</p>
<p>The approach for parallel processing in <code>sits</code>, depicted in the figure below, has the following steps:</p>
<ol style="list-style-type: decimal">
<li>Based on the block size of individual COG files, calculate the size of each chunk that has to be loaded in memory, considering the number of bands and the length of the timeline. Chunk access is optimized for efficient transfer of data blocks.</li>
<li>Divide the total memory available by the chunk size to find out how many processes can be run in parallel.</li>
<li>Each core processes a chunk and produces a subset of the result.</li>
<li>Repeat the process until all chunks in the cube have been processed.</li>
<li>Check that subimages have been produced correctly. If there is a problem with one or more subimages, run a failure recovery procedure to ensure all data is processed.</li>
<li>After all subimages are generated, join them to obtain the result.</li>
</ol>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-120"></span>
<img src="images/sits_parallel.png" alt="Parallel processing in sits (source: Simoes et al.,2021)." width="90%" height="90%"><p class="caption">
Figure 69: Parallel processing in sits (source: Simoes et al.,2021).
</p>
</div>
<p>This approach has many advantages. It works in any virtual machine that supports R and has no dependencies on proprietary software. Processing is done in a concurrent and independent way, with no communication between workers. Failure of one worker does not cause failure of the big data processing. The software is prepared to resume classification processing from the last processed chunk, preventing against failures such as memory exhaustion, power supply interruption, or network breakdown.</p>
<p>To reduce processing time, it is necessary to adjust <code><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify()</a></code>, <code><a href="https://rdrr.io/pkg/sits/man/sits_smooth.html">sits_smooth()</a></code>, and <code><a href="https://rdrr.io/pkg/sits/man/sits_label_classification.html">sits_label_classification()</a></code> according to the capabilities of the host environment. The <code>memsize</code> parameter controls the size of the main memory (in GBytes) to be used for classification. A practical approach is to set <code>memsize</code> to the maximum memory available in the virtual machine for classification and to chose <code>multicores</code> as the largest number of cores available. Based on the memory available and the size of blocks in COG files, <code>sits</code> will access the images in an optimized way. In this way, <code>sits</code> tries to ensure best possible use of the available resources.</p>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="machine-learning-for-data-cubes.html">Machine Learning for Data Cubes</a></div>
<div class="next"><a href="validation-and-accuracy-measurements.html">Validation and accuracy measurements</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#image-classification-in-data-cubes">Image Classification in Data Cubes</a></li>
<li><a class="nav-link" href="#training-the-classification-model">Training the classification model</a></li>
<li><a class="nav-link" href="#building-a-data-cube">Building a data cube</a></li>
<li><a class="nav-link" href="#training-a-deep-learning-model">Training a deep learning model</a></li>
<li><a class="nav-link" href="#classification-using-parallel-processing">Classification using parallel processing</a></li>
<li><a class="nav-link" href="#post-classification-smoothing">Post-classification smoothing</a></li>
<li><a class="nav-link" href="#bayesian-smoothing">Bayesian smoothing</a></li>
<li>
<a class="nav-link" href="#bilateral-smoothing">Bilateral smoothing</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#how-parallel-processing-works">How parallel processing works</a></li></ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</strong>" was written by Gilberto Camara, Rolf Simoes, Felipe Souza, Charlotte Pelletier, Alber Sanchez, Pedro Ribeiro Andrade, Karine Ferreira, Gilberto Queiroz. It was last built on 2023-01-23.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
